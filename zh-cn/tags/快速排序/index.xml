<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>快速排序 on JHCx330-蒋金恒</title>
        <link>https://YCstudent.github.io/hugo-dev/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
        <description>Recent content in 快速排序 on JHCx330-蒋金恒</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>JHCx330</copyright>
        <lastBuildDate>Tue, 05 Nov 2024 05:28:38 +0000</lastBuildDate><atom:link href="https://YCstudent.github.io/hugo-dev/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>快速排序算法</title>
        <link>https://YCstudent.github.io/hugo-dev/zh-cn/p/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
        <pubDate>Sat, 02 Nov 2024 23:51:36 +0800</pubDate>
        
        <guid>https://YCstudent.github.io/hugo-dev/zh-cn/p/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
        <description>&lt;h2 id=&#34;快速排序模板以-j-为分界&#34;&gt;快速排序模板(以 j 为分界)
&lt;/h2&gt;&lt;p&gt;快排属于&lt;strong&gt;分治算法&lt;/strong&gt;，分治算法都有三步：&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;分成&lt;/strong&gt;子问题&lt;/p&gt;
&lt;p&gt;2.递归&lt;strong&gt;处理&lt;/strong&gt;子问题&lt;/p&gt;
&lt;p&gt;3.子问题&lt;strong&gt;合并&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void quick_sort(int q[], int l, int r)
{
    //递归的终止情况
    if(l &amp;gt;= r) return;

    //第一步：分成子问题
    int i = l - 1, j = r + 1, x = q[l + r &amp;gt;&amp;gt; 1];
    while(i &amp;lt; j)
    {
        do i++; while(q[i] &amp;lt; x);
        do j--; while(q[j] &amp;gt; x);
        if(i &amp;lt; j) swap(q[i], q[j]);
    }

    //第二步：递归处理子问题
    quick_sort(q, l, j), quick_sort(q, j + 1, r);

    //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;问题实践&#34;&gt;问题实践
&lt;/h2&gt;&lt;h3 id=&#34;第一题&#34;&gt;第一题
&lt;/h3&gt;&lt;p&gt;给定你一个长度为 n
的整数数列。&lt;/p&gt;
&lt;p&gt;请你使用快速排序对这个数列按照从小到大进行排序。&lt;/p&gt;
&lt;p&gt;并将排好序的数列按顺序输出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入共两行，第一行包含整数 n。&lt;/p&gt;
&lt;p&gt;第二行包含 n
个整数（所有整数均在 1∼109
范围内），表示整个数列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出共一行，包含 n
个整数，表示排好序的数列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$
1≤n≤100000
$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;5
3 1 2 4 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;参考答案&#34;&gt;参考答案
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

const int N = 1000010;
int q[N];
int n;

void quick_sort(int q[], int l, int r)
{
    if (l &amp;gt;= r) return;

    int i = l - 1, j = r + 1, x = q[l + r &amp;gt;&amp;gt; 1];
    while (i &amp;lt; j)
    {
        do i ++; while(q[i] &amp;lt; x);
        do j --; while(q[j] &amp;gt; x);
        if (i &amp;lt; j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}

int main()
{
    scanf(&amp;#34;%d&amp;#34;, &amp;amp;n);

    for (int i = 0; i &amp;lt; n; i ++) scanf(&amp;#34;%d&amp;#34;, &amp;amp;q[i]);

    quick_sort(q, 0, n - 1);

    for (int i = 0; i &amp;lt; n; i++) printf(&amp;#34;%d &amp;#34;, q[i]);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;第-k-个数&#34;&gt;第 k 个数
&lt;/h3&gt;&lt;p&gt;给定一个长度为 n
的整数数列，以及一个整数 k
，请用快速选择算法求出数列从小到大排序后的第 k
个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行包含两个整数 n
和 k
。&lt;/p&gt;
&lt;p&gt;第二行包含 n
个整数（所有整数均在 1∼109
范围内），表示整数数列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出一个整数，表示数列的第 k
小数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$
1≤n≤100000,
$&lt;/p&gt;
&lt;p&gt;$
1≤k≤n
$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;5 3
2 4 1 5 3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;3
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;参考答案-1&#34;&gt;参考答案
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

const int N = 1000010;

int q[N];
int n, k;

int quick_sort(int l, int r, int k)
{
    if (l == r) return q[l];

    int i = l - 1, j = r + 1, x = q[l + r &amp;gt;&amp;gt; 1];

    while (i &amp;lt; j)
    {
        do i++;while (q[i] &amp;lt; x);
        do j--;while (q[j] &amp;gt; x);
        if (i &amp;lt; j) swap (q[i], q[j]);
    }
   int sl = j - l + 1;
   if (k &amp;lt;= sl) return quick_sort(l, j, k);

   else return quick_sort(j + 1, r, k - sl);
}
int main()
{
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    for (int i = 0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; q[i];

    cout &amp;lt;&amp;lt; quick_sort(0, n - 1, k) &amp;lt;&amp;lt;endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;总结&#34;&gt;总结
&lt;/h2&gt;&lt;p&gt;快速排序算法是基础中的基础，将模板熟练并灵活应用至关重要！！&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
