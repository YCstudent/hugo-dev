[{"content":"快速排序模板(以 j 为分界) 快排属于分治算法，分治算法都有三步：\n1.分成子问题\n2.递归处理子问题\n3.子问题合并\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void quick_sort(int q[], int l, int r) { //递归的终止情况 if(l \u0026gt;= r) return; //第一步：分成子问题 int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while(i \u0026lt; j) { do i++; while(q[i] \u0026lt; x); do j--; while(q[j] \u0026gt; x); if(i \u0026lt; j) swap(q[i], q[j]); } //第二步：递归处理子问题 quick_sort(q, l, j), quick_sort(q, j + 1, r); //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤 } 问题实践 第一题 给定你一个长度为 n 的整数数列。\n请你使用快速排序对这个数列按照从小到大进行排序。\n并将排好序的数列按顺序输出。\n输入格式\n输入共两行，第一行包含整数 n。\n第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。\n输出格式\n输出共一行，包含 n 个整数，表示排好序的数列。\n数据范围\n$ 1≤n≤100000 $\n输入样例：\n1 2 5 3 1 2 4 5 输出样例：\n1 1 2 3 4 5 参考答案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; int q[N]; int n; void quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++; while(q[i] \u0026lt; x); do j --; while(q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; i ++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;q[i]); quick_sort(q, 0, n - 1); for (int i = 0; i \u0026lt; n; i++) printf(\u0026#34;%d \u0026#34;, q[i]); return 0; } 第 k 个数 给定一个长度为 n 的整数数列，以及一个整数 k ，请用快速选择算法求出数列从小到大排序后的第 k 个数。\n输入格式\n第一行包含两个整数 n 和 k 。\n第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整数数列。\n输出格式\n输出一个整数，表示数列的第 k 小数。\n数据范围\n$ 1≤n≤100000, $\n$ 1≤k≤n $\n输入样例：\n1 2 5 3 2 4 1 5 3 输出样例：\n1 3 参考答案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; int q[N]; int n, k; int quick_sort(int l, int r, int k) { if (l == r) return q[l]; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i++;while (q[i] \u0026lt; x); do j--;while (q[j] \u0026gt; x); if (i \u0026lt; j) swap (q[i], q[j]); } int sl = j - l + 1; if (k \u0026lt;= sl) return quick_sort(l, j, k); else return quick_sort(j + 1, r, k - sl); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; q[i]; cout \u0026lt;\u0026lt; quick_sort(0, n - 1, k) \u0026lt;\u0026lt;endl; return 0; } 总结 快速排序算法是基础中的基础，将模板熟练并灵活应用至关重要！！\n","date":"2024-11-02T23:51:36+08:00","permalink":"https://YCstudent.github.io/hugo-dev/p/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","title":"快速排序算法"},{"content":"主要内容 这个博客网站主要分享我的日常学习内容、总结的笔记什么的，还会分享一些专业的知识，也会转载一些优秀创作者的文章供大家参考，大家拭目以待！！！\n更新计划 本人目前是在读本科生，可能没有很多时间投入到博客内容上面，但我会尽力更新，更新时间不定。如果有什么更新内容方面的建议，可以给我发邮箱 QQ:2917321268@qq.com\n","date":"2024-11-01T23:31:40+08:00","permalink":"https://YCstudent.github.io/hugo-dev/p/%E7%BB%88%E4%BA%8E%E5%BC%80%E5%A7%8B%E4%BA%86%E8%BF%99%E6%98%AF%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/","title":"终于开始了，这是我的第一个博客"}]